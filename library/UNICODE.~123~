(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE "INTERLISP")(FILECREATED " 6-Aug-2020 17:49:17" {DSK}<Users>kaplan>Local>medley3.5>lispcore>library>UNICODE.;123 53952        changes to%:  (FNS UTF8.OUTCHARFN UTF8.INCCODEFN UTF8.PEEKCCODEFN MAKE-UNICODE-FORMATS                          UTF16BE.INCCODEFN UTF16BE.OUTCHARFN)                    (VARS UNICODECOMS)      previous date%: " 6-Aug-2020 09:37:13" {DSK}<Users>kaplan>Local>medley3.5>lispcore>library>UNICODE.;120)(PRETTYCOMPRINT UNICODECOMS)(RPAQQ UNICODECOMS       [[COMS               (* ;; "External formats")              (FNS UTF8.OUTCHARFN UTF8.INCCODEFN UTF8.PEEKCCODEFN \UTF8.BACKCHARFN)              (FNS UTF16BE.OUTCHARFN UTF16BE.INCCODEFN UTF16BE.PEEKCCODEFN \UTF16.BACKCHARFN)              (FNS MAKE-UNICODE-FORMATS)              (P (MAKE-UNICODE-FORMATS))              (ADDVARS (*DEFAULT-EXTERNAL-FORMATS* (UNIX :UTF8]        [COMS               (* ;; "Unicode mapping files")              (FNS READ-UNICODE-MAPPING-FILENAMES READ-UNICODE-MAPPING WRITE-UNICODE-MAPPING                    WRITE-UNICODE-INCLUDED WRITE-UNICODE-MAPPING-HEADER WRITE-UNICODE-MAPPING-FILENAME                   )              (VARS XCCS-SET-NAMES)                            (* ;; "Automate dumping of a documentation prefix")              [DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (MISSINGCODE (CL:PARSE-INTEGER "FFFE"                                                                               :RADIX 16))                                                      (UNDEFINEDCODE (CL:PARSE-INTEGER "FFFF" :RADIX                                                                            16]              (VARS UNICODE-MAPPING-HEADER)              (INITVARS (UNICODEDIRECTORIES NIL))              (P (PUSHNEW UNICODEDIRECTORIES (PACK* (UNIX-GETENV "MEDLEYDIR")                                                    '/lispcore/unicode/xerox/]        (COMS               (* ;; "Set up translation tables for UTF8 and UTFBE external formats")              (FNS MAKE-UNICODE-TRANSLATION-TABLES)              [INITVARS (DEFAULT-XCCS-CHARSETS '(LATIN SYMBOLS1 SYMBOLS2 EXTENDED-LATIN FORMS                                                        SYMBOLS3 SYMBOLS4 ACCENTED-LATIN]              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS UNICODE.TRANSLATE))              [DECLARE%: DONTEVAL@LOAD DOCOPY (P (MAKE-UNICODE-TRANSLATION-TABLES (                                                                                 READ-UNICODE-MAPPING                                                                                                                                                                   DEFAULT-XCCS-CHARSETS                                                                                   T)                                                        '*XCCSTOUNICODE*                                                        '*UNICODETOXCCS*]              (GLOBALVARS *XCCSTOUNICODE* *UNICODETOXCCS*))        (FNS HEXSTRING UTF8STRING)        (FNS SHOWCHARS)        (DECLARE%: EVAL@COMPILE DONTCOPY                (* ;; "This is taken from FILEIO")               (CONSTANTS (LF.EOLC 1))               (P (EVAL (SYSRECLOOK1 'EXTERNALFORMAT])(* ;; "External formats")(DEFINEQ(UTF8.OUTCHARFN  [LAMBDA (STREAM CHARCODE RAW)                         (* ; "Edited  6-Aug-2020 17:12 by rmk:")                                                            (* ; "Edited 30-Jan-2020 23:08 by rmk:")    (* ;; "PRINT UTF8 sequence for CHARCODE.  Do not do XCCS to Unicode translation of RAW.")    (CL:UNLESS RAW        (SETQ CHARCODE (UNICODE.TRANSLATE CHARCODE *XCCSTOUNICODE*)))    (IF (ILESSP CHARCODE 128)        THEN (\BOUT STREAM CHARCODE)      ELSEIF (ILESSP CHARCODE 2048)        THEN                                             (* ; "x800")              (\BOUT STREAM (LOGOR (LLSH 3 6)                                   (LRSH CHARCODE 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSEIF (ILESSP CHARCODE 65536)        THEN                                             (* ; "x10000")              (\BOUT STREAM (LOGOR (LLSH 7 5)                                   (LRSH CHARCODE 12)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 6 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSEIF (ILESSP CHARCODE 2097152)        THEN                                             (* ; "x200000")              (\BOUT STREAM (LOGOR (LLSH 15 4)                                   (LRSH CHARCODE 18)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 12 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 6 6)))              (\BOUT STREAM (LOGOR (LLSH 2 6)                                   (LOADBYTE CHARCODE 0 6)))      ELSE (ERROR "CHARCODE too big for UTF8" CHARCODE])(UTF8.INCCODEFN  [LAMBDA (STREAM COUNTP RAW)                           (* ; "Edited  6-Aug-2020 17:13 by rmk:")    (* ;; "Do not do UNICODE to XCSS translation if RAW.")    (* ;; "Test for smallp because the stream's End-of-file operation may suppress the error")    (LET (BYTE1 BYTE2 BYTE3 BYTE4 CODE (COUNT 1))         (SETQ BYTE1 (\BIN STREAM))         (* ;; "Distinguish on header bytes (modulo peculiar EOF behavior--the caller will get whatever ended up in BYTE1")         (CL:WHEN (SMALLP BYTE1)             [SETQ CODE (IF (ILESSP BYTE1 128)                            THEN                                   (* ;; "Test first:  Ascii is the common case")                                  BYTE1                          ELSEIF (IGEQ BYTE1 (LLSH 15 4))                            THEN                         (* ; "4 bytes")                                  (SETQ BYTE2 (\BIN STREAM))                                  (CL:WHEN (OR (NOT (SMALLP BYTE2))                                               (ILESSP BYTE2 128))                                      (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                                  (SETQ BYTE3 (\BIN STREAM))                                  (CL:WHEN (OR (NOT (SMALLP BYTE3))                                               (ILESSP BYTE3 128))                                      (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                                  (SETQ BYTE4 (\BIN STREAM))                                  (CL:WHEN (OR (NOT (SMALLP BYTE4))                                               (ILESSP BYTE4 128))                                      (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3 BYTE4)))                                  (SETQ COUNT 4)                                  (LOGOR (LLSH (LOADBYTE BYTE1 0 3)                                               18)                                         (LLSH (LOADBYTE BYTE2 0 6)                                               12)                                         (LLSH (LOADBYTE BYTE3 0 6)                                               6)                                         (LOADBYTE BYTE4 0 6))                          ELSEIF (IGEQ BYTE1 (LLSH 7 5))                            THEN                         (* ; "3 bytes")                                  (SETQ BYTE2 (\BIN STREAM))                                  (CL:WHEN (OR (NOT (SMALLP BYTE2))                                               (ILESSP BYTE2 128))                                      (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                                  (SETQ BYTE3 (\BIN STREAM))                                  (CL:WHEN (OR (NOT (SMALLP BYTE3))                                               (ILESSP BYTE3 128))                                      (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                                  (SETQ COUNT 3)                                  (LOGOR (LLSH (LOADBYTE BYTE1 0 4)                                               12)                                         (LLSH (LOADBYTE BYTE2 0 6)                                               6)                                         (LOADBYTE BYTE3 0 6))                          ELSE                           (* ; "Must be 2 bytes")                                (SETQ COUNT 2)                                (SETQ BYTE2 (\BIN STREAM))                                (CL:WHEN (OR (NOT (SMALLP BYTE2))                                             (ILESSP BYTE2 128))                                    (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                                (LOGOR (LLSH (LOADBYTE BYTE1 0 5)                                             6)                                       (LOADBYTE BYTE2 0 6])         (CL:UNLESS (OR RAW (NOT (SMALLP CODE)))             (SETQ CODE (UNICODE.TRANSLATE CODE *UNICODETOXCCS*)))         (CL:IF COUNTP             (CL:VALUES CODE COUNT)             CODE)])(UTF8.PEEKCCODEFN  [LAMBDA (STREAM NOERROR COUNTP RAW)                   (* ; "Edited  6-Aug-2020 17:12 by rmk:")    (* ;; "Modeled this after \EUCPEEK on LLREAD.  In the multi-byte (non-ASCII) case, backs the file pointer to the beginning by the proper number of \BACKFILEPTRs, and returns a count of 0.  Returns NIL if NOERROR and either invalid UTF8 or end of file.")    (* ;; "Could be that the caller takes care of backing up the file position if the number of binned-bytes is returned.")    (* ;; "Do not do UNICODE to XCCS translation if RAW")    (PROG (BYTE1 BYTE2 BYTE3 BYTE4 CODE)          (SETQ BYTE1 (\PEEKBIN STREAM NOERROR))     (* ;; "Distinguish on header bytex")          (CL:UNLESS BYTE1              (RETURN (AND COUNTP (CL:VALUES NIL 0))))          [IF (ILESSP BYTE1 128)              THEN                     (* ;;                   "Test first:  Ascii is the common case.  No need to back up, since we peeked.")                    (SETQ CODE BYTE1)            ELSEIF (IGEQ BYTE1 (LLSH 15 4))              THEN                                       (* ; "4 bytes")                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE2 128))                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE3 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE3 128))                        (\BACKFILEPTR STREAM)                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (SETQ BYTE4 (\PEEKBIN STREAM NOERROR))   (* ;                                                            "PEEK the last, no need to back it up")                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (IF (AND BYTE4 (IGEQ BYTE4 128))                        THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 3)                                                         18)                                                   (LLSH (LOADBYTE BYTE2 0 6)                                                         12)                                                   (LLSH (LOADBYTE BYTE3 0 6)                                                         6)                                                   (LOADBYTE BYTE4 0 6)))                      ELSEIF NOERROR                      ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3 BYTE4)))            ELSEIF (IGEQ BYTE1 (LLSH 7 5))              THEN                                       (* ; "3 bytes")                    (\BIN STREAM)                    (CL:UNLESS (AND (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                                    (IGEQ BYTE2 128))                        (\BACKFILEPTR STREAM)                        (OR NOERROR (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2)))                        (RETURN (IF COUNTP                                    THEN (CL:VALUES CODE 0)                                  ELSE CODE)))                    (\BIN STREAM)                    (SETQ BYTE3 (\PEEKBIN STREAM NOERROR))                    (\BACKFILEPTR STREAM)                    (\BACKFILEPTR STREAM)                    (IF (AND BYTE3 (IGEQ BYTE3 128))                        THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 4)                                                         12)                                                   (LLSH (LOADBYTE BYTE2 0 6)                                                         6)                                                   (LOADBYTE BYTE3 0 6)))                      ELSEIF NOERROR                      ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2 BYTE3)))            ELSE                                         (* ; "Must be 2 bytes")                  (\BIN STREAM)                  (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                  (\BACKFILEPTR STREAM)                  (IF (AND BYTE2 (IGEQ BYTE2 128))                      THEN (SETQ CODE (LOGOR (LLSH (LOADBYTE BYTE1 0 5)                                                       6)                                                 (LOADBYTE BYTE2 0 6)))                    ELSEIF NOERROR                    ELSE (ERROR "INVALID UTF8 SEQUENCE" (LIST BYTE1 BYTE2]          (CL:WHEN (AND CODE (NOT RAW))              (SETQ CODE (UNICODE.TRANSLATE CODE *UNICODETOXCCS*)))          (RETURN (IF COUNTP                      THEN (CL:VALUES CODE 0)                    ELSE CODE])(\UTF8.BACKCHARFN  [LAMBDA (STREAM COUNTP)                               (* ; "Edited 26-Jul-2020 10:41 by rmk:")    (* ;; "\BACKFILEPTR is NIL at beginning of FILE, just return COUNT")    (BIND (C _ 0) WHILE (CL:WHEN (\BACKFILEPTR STREAM)                                    (ADD C 1)                                    (EQ 2 (LRSH (\PEEKBIN STREAM)                                                6))) REPEATUNTIL (EQ C 4)       FINALLY (RETURN (AND COUNTP C]))(DEFINEQ(UTF16BE.OUTCHARFN
  [LAMBDA (STREAM CHARCODE RAW)                                                            (* ; "Edited  6-Aug-2020 17:00 by rmk:")                                                            (* ; "Edited 30-Jan-2020 23:08 by rmk:")
  (* ;; "PRINT UTF16 sequence for CHARCODE.  Do not do XCCS to UNICODE translation if RAW.")

  (CL:UNLESS RAW(SETQ CHARCODE (UNICODE.TRANSLATE CHARCODE *XCCSTOUNICODE*)))
  (\BOUT STREAM (LRSH CHARCODE 8))
  (\BOUT STREAM (LOGAND CHARCODE 255])(UTF16BE.INCCODEFN  [LAMBDA (STREAM COUNTP RAW)                           (* ; "Edited  6-Aug-2020 17:48 by rmk:")    (* ;;   "Do not do UNICODE to XCCS translation if RAW.  Test for SMALLPin case of funky EOF behavior")    (LET (CODE BYTE1 BYTE2 COUNT)         (IF [AND (SMALLP (SETQ BYTE1 (\BIN STREAM)))                      (SMALLP (SETQ BYTE2 (\BIN STREAM]             THEN (SETQ COUNT 2)                   (SETQ CODE (LOGOR (LLSH (\BIN STREAM)                                           8)                                     (\BIN STREAM)))                   (CL:UNLESS RAW                       (SETQ CODE (UNICODE.TRANSLATE CODE *UNICODETOXCCS*)))                   (CL:IF COUNTP                       (CL:VALUES CODE COUNT)                       CODE)           ELSE (ERROR "ODD NUMBER OF BYTES IN UTF16 FILE" STREAM])(UTF16BE.PEEKCCODEFN  [LAMBDA (STREAM NOERROR COUNTP RAW)                   (* ; "Edited 30-Jul-2020 14:06 by rmk:")    (* ;; "Could be that the caller takes care of backing up the file position if the number of binned-bytes is returned.")    (* ;; "Do not do UNICODE to XCCS translation if RAW")    (LET (BYTE1 BYTE2 CODE)         (SETQ BYTE1 (\PEEKBIN STREAM NOERROR))         (IF BYTE1             THEN (\BIN STREAM)                   (SETQ BYTE2 (\PEEKBIN STREAM NOERROR))                   (\BACKFILEPTR STREAM)                   (IF BYTE2                       THEN (SETQ CODE (LOGOR (LLSH BYTE1 8)                                                  BYTE2))                             (CL:IF COUNTP                                 (CL:VALUES (CL:IF RAW                                                CODE                                                (UNICODE.TRANSLATE CODE *UNICODETOXCCS*))                                        0))                     ELSEIF NOERROR                     ELSE (AND COUNTP (CL:VALUES NIL 0)))           ELSEIF NOERROR             THEN (AND COUNTP (CL:VALUES NIL 0))           ELSE (ERROR "INVALID UTF16 CHARACTER" (LIST BYTE1 BYTE2])(\UTF16.BACKCHARFN  [LAMBDA (STREAM COUNTP)                               (* ; "Edited 26-Jul-2020 13:05 by rmk:")    (* ;; "\BACKFILEPTR is NIL at beginning of FILE, just return COUNT.")    (* ;; "Common for big-ending and little-ending")    (IF (NOT (\BACKFILEPTR STREAM))        THEN (AND COUNTP 0)      ELSEIF (\BACKFILEPTR STREAM)        THEN (AND COUNTP 2)      ELSE (AND COUNTP 1]))(DEFINEQ(MAKE-UNICODE-FORMATS  [LAMBDA NIL                                           (* ; "Edited  6-Aug-2020 17:12 by rmk:")    (* ;; "RAW formats do not do XCCS/Unicode translation, just deal with the byte encoding.")    (* ;; "The EOL forces the EOLCONVENTION of the stream to be changed to LF, so that \CHECKEOLC will do the conversion of LF to CR.")    (* ;; "This should be handled in the reading functions here--\CHECKEOLC is a general mistake.")    (\INSTALL.EXTERNALFORMAT :UTF16BE (CREATE EXTERNALFORMAT                                             EOLVALID _ T                                             EOL _ LF.EOLC                                             INCCODEFN _ (FUNCTION UTF16BE.INCCODEFN)                                             PEEKCCODEFN _ (FUNCTION UTF16BE.PEEKCCODEFN)                                             BACKCHARFN _ (FUNCTION \UTF16.BACKCHARFN)                                             FILEOUTCHARFN _ (FUNCTION UTF16BE.OUTCHARFN)))    [\INSTALL.EXTERNALFORMAT :UTF16BE-RAW (CREATE EXTERNALFORMAT                                                 INCCODEFN _ [FUNCTION (LAMBDA (STREAM)                                                                         (UTF16BE.INCCODEFN                                                                          STREAM T]                                                 PEEKCCODEFN _ [FUNCTION (LAMBDA (STREAM NOERROR                                                                                         COUNTP)                                                                           (UTF16BE.PEEKCCODEFN                                                                            STREAM NOERROR COUNTP T]                                                 BACKCHARFN _ (FUNCTION \UTF16.BACKCHARFN)                                                 FILEOUTCHARFN _ (FUNCTION (LAMBDA (STREAM CHARCODE)                                                                             (UTF16BE.OUTCHARFN                                                                              STREAM CHARCODE T]    [\INSTALL.EXTERNALFORMAT :UTF8-RAW (CREATE EXTERNALFORMAT                                              INCCODEFN _ [FUNCTION (LAMBDA (STREAM COUNTP)                                                                      (UTF8.INCCODEFN STREAM                                                                              COUNTP T]                                              PEEKCCODEFN _ [FUNCTION (LAMBDA (STREAM NOERROR COUNTP)                                                                        (UTF8.PEEKCCODEFN STREAM                                                                               NOERROR COUNTP T]                                              BACKCHARFN _ (FUNCTION \UTF8.BACKCHARFN)                                              FILEOUTCHARFN _ (FUNCTION (LAMBDA (STREAM CHARCODE)                                                                          (UTF8.OUTCHARFN STREAM                                                                                 CHARCODE T]    (\INSTALL.EXTERNALFORMAT :UTF8 (CREATE EXTERNALFORMAT                                          EOLVALID _ T                                          EOL _ LF.EOLC                                          INCCODEFN _ (FUNCTION UTF8.INCCODEFN)                                          PEEKCCODEFN _ (FUNCTION UTF8.PEEKCCODEFN)                                          BACKCHARFN _ (FUNCTION \UTF8.BACKCHARFN)                                          FILEOUTCHARFN _ (FUNCTION UTF8.OUTCHARFN]))(MAKE-UNICODE-FORMATS)(ADDTOVAR *DEFAULT-EXTERNAL-FORMATS* (UNIX :UTF8))(* ;; "Unicode mapping files")(DEFINEQ(READ-UNICODE-MAPPING-FILENAMES  [LAMBDA (FILESPEC)                                  (* ; "Edited  5-Aug-2020 15:59 by kaplan")                                                             (* ;                                                            "Edited  4-Aug-2020 17:31 by rmk:")    (FOR F X CSI INSIDE FILESPEC       COLLECT (IF (FINDFILE (PACKFILENAME 'BODY F 'EXTENSION 'TXT)                                  T UNICODEDIRECTORIES)                     ELSEIF [SETQ CSI (OR (SASSOC F XCCS-SET-NAMES)                                              (FIND N IN XCCS-SET-NAMES                                                 SUCHTHAT (EQ F (CADR N]                       THEN (FINDFILE (PACKFILENAME 'BODY (CONCAT 'XCCS- (CAR CSI)                                                                     '=                                                                     (CADR CSI))                                                 'EXTENSION                                                 'TXT)                                       T UNICODEDIRECTORIES)                     ELSE F])(READ-UNICODE-MAPPING  [LAMBDA (FILESPEC NOPRINT NOERROR)                    (* ; "Edited  6-Aug-2020 08:24 by rmk:")    (* ;; "Combines the char-mapping tables from FILES coded in the Uncode-CDROM format.  Comments prefixed by # and")    (* ;; "               Column 1:  Input hex code in the format %"0xXXXX%" (fromcode)")    (* ;; "               Column 2:  Corresponding Unicode code in the format %"0xXXXX%" (tocode)")    (* ;; "               Column 3:  (after #) Character name in some mapping files, utf-8 character  for XCCS mapping files")    (* ;; "")    (* ;; "Result is a list of (fromcode tocode) integer pairs, where pairs are suppress where fromcode and tocode are the same, since the absence of a pair indicates identity.")    (FOR FILE IN (READ-UNICODE-MAPPING-FILENAMES FILESPEC)       JOIN (CL:WITH-OPEN-FILE (STREAM FILE :DIRECTION :INPUT :EXTERNAL-FORMAT :UTF8-RAW)                       (BIND FROMCODE TOCODE AFTERFROM LINE [WSBITTABLE                                                                 _                                                                 (MAKEBITTABLE (CHARCODE (TAB SPACE]                              [CBITTABLE _ (MAKEBITTABLE (CHARCODE (TAB SPACE %#]                          FIRST (CL:UNLESS (FILEPOS "Name:" STREAM NIL NIL NIL T)                                        (ERROR "NOT A UNICODE MAPPING FILE" (FULLNAME STREAM)))                                (SETQ LINE (CL:READ-LINE STREAM NIL NIL))                                (CL:UNLESS NOPRINT                                    (PRINTOUT T T "Unicode mapping:  " (CL:STRING-TRIM " " LINE)                                           T)) WHILE (SETQ LINE (CL:READ-LINE STREAM NIL NIL))                          UNLESS (OR [EQ (CHARCODE %#)                                             (CHCON1 (SETQ LINE (CL:STRING-LEFT-TRIM " " LINE]                                         (EQ 0 (NCHARS LINE)))                          COLLECT (SETQ AFTERFROM (STRPOSL WSBITTABLE LINE))                                [SETQ FROMCODE (CHARCODE.DECODE (SUBSTRING LINE 1 (SUB1 AFTERFROM)                                                                       (CONSTANT (CONCAT]                                [SETQ LINE (CL:STRING-LEFT-TRIM '(#\Space #\Tab)                                                  (SUBSTRING LINE AFTERFROM NIL (CONSTANT (CONCAT]                                [SETQ TOCODE (CHARCODE.DECODE                                              (SUBSTRING LINE 1 [SUB1 (OR (STRPOSL CBITTABLE LINE)                                                                          (ADD1 (NCHARS LINE]                                                     NIL                                                     (CONSTANT (CONCAT]                                (LIST FROMCODE TOCODE])(WRITE-UNICODE-MAPPING  [LAMBDA (MAPPING INCLUDECHARSETS FILE EMPTYOK)        (* ; "Edited  6-Aug-2020 08:20 by rmk:")    (* ;; "Writes a symbol unicode mapping file.  Mapping is a list of (XCCS-code Unicode) pairs, which may contain codes in multiple character sets.")    (* ;; "If FILE is NIL, it defaults to a name XCCS- followed by the octal character sets in the mapping, in the unicode/XEROX directory.")    (* ;; "The output lines are of the form x0XXX<tab>x0UUUU<tab>#  Unicode-char")    (* ;;   "If INCLUDECHARSETS=T then the mappings are split up into separate per-character set files.")    (* ;; "Otherwise, all and only mappings included in thos charsets are included in a single output file--an implicit subset.")    (IF (AND (EQ INCLUDECHARSETS T)                 (NULL FILE))        THEN (IF MAPPING                     THEN (FOR CSI F IN XCCS-SET-NAMES WHEN (SETQ F                                                                             (WRITE-UNICODE-MAPPING                                                                              MAPPING                                                                              (CAR CSI)                                                                              NIL T)) COLLECT                                                                                      F)                   ELSE (PRINTOUT T "THERE ARE NO MAPPINGS" T)                         NIL)      ELSE      (LET       (IMAPPING CSETINFO RANGES)       (CL:MULTIPLE-VALUE-SETQ (IMAPPING CSETINFO RANGES)              (WRITE-UNICODE-INCLUDED MAPPING INCLUDECHARSETS))       (IF IMAPPING           THEN (CL:WITH-OPEN-FILE                     (STREAM (WRITE-UNICODE-MAPPING-FILENAME FILE CSETINFO RANGES)                            :DIRECTION :OUTPUT :IF-EXISTS :NEW-VERSION :EXTERNAL-FORMAT :UTF8-RAW)                     (WRITE-UNICODE-MAPPING-HEADER STREAM CSETINFO RANGES)                     (SORT IMAPPING T)                     (FOR M CSET LEFTC RIGHTC CSI IN IMAPPING                        DO (SETQ LEFTC (CAR M))                              (SETQ RIGHTC (CADR M))                              (CL:UNLESS (EQ CSET (LRSH LEFTC 8))                                  (SETQ CSET (LRSH LEFTC 8))                                  (SETQ CSI (ASSOC CSET CSETINFO))                                  (PRINTOUT STREAM T "#  " .P2 (CADR CSI)                                         " "                                         (CADDR CSI)                                         T))                              (PRINTOUT STREAM "0x" (HEXSTRING LEFTC 4)                                     "	" "0x" (HEXSTRING RIGHTC 4)                                     "	#  "                                     (SELECTC RIGHTC                                         (UNDEFINEDCODE                                                         (* ;; "FFFF")                                                        "UNDEFINED")                                         (MISSINGCODE                                                       (* ;; "FFFE")                                                      "MISSING")                                         (IF (ILESSP RIGHTC 32)                                             THEN [CONCAT "^" (CHARACTER (IPLUS RIGHTC                                                                                    (CHARCODE @]                                           ELSE (CHARACTER RIGHTC)))                                     T))                     (FULLNAME STREAM))         ELSEIF (NOT EMPTYOK)           THEN (PRINTOUT T "THERE ARE NO MAPPINGS")                 (CL:WHEN INCLUDECHARSETS                     (PRINTOUT T " FOR " .PPVTL (MKLIST INCLUDECHARSETS)                            T))                 NIL])(WRITE-UNICODE-INCLUDED  [LAMBDA (MAPPING INCLUDECHARSETS)                     (* ; "Edited  4-Aug-2020 17:47 by rmk:")    (* ;; "CSETINFO is a list of (num string name) for each included character set.")    (LET (CHARSETS CSETINFO RANGES ICSETS IMAPPING)         (* ;; "Normalize the INCLUDECHARSETS, then reduce MAPPING to the included mappings")         [SETQ ICSETS (FOR C POS KNOWN INSIDE (OR INCLUDECHARSETS (FOR CSI IN                                                                                        XCCS-SET-NAMES                                                                             COLLECT (CAR CSI)))                         JOIN [SETQ KNOWN (OR (SASSOC C XCCS-SET-NAMES)                                                  (FIND N IN XCCS-SET-NAMES                                                     SUCHTHAT (EQ C (CADR N)))                                                  (HELP "UNKNOWN CHARACTER SET" (OCTALSTRING C]                               (IF (SETQ POS (STRPOS "-" (CAR KNOWN)))                                   THEN (FOR I FROM (CL:PARSE-INTEGER (SUBSTRING                                                                                   (CAR KNOWN)                                                                                   1                                                                                   (SUB1 POS))                                                                       :RADIX 8)                                               TO (CL:PARSE-INTEGER (SUBSTRING (CAR KNOWN)                                                                               (ADD1 POS))                                                             :RADIX 8)                                               COLLECT (LIST I (OCTALSTRING I)                                                                 (CADR KNOWN)))                                 ELSE (CONS (CONS (CL:PARSE-INTEGER (CAR KNOWN)                                                             :RADIX 8)                                                      KNOWN]         (SETQ IMAPPING (FOR M CSI IN MAPPING WHEN (SETQ CSI (ASSOC (LRSH (CAR M)                                                                                      8)                                                                                ICSETS))                           COLLECT                                  (* ;; "The attested subset of INCLUDED")                                 (CL:UNLESS (MEMB CSI CSETINFO)                                        (PUSH CSETINFO CSI))                                 M))         (* ;; "Sort as numbers, not octal strings, then group into consecutive ranges")         (SETQ CSETINFO (SORT CSETINFO T))         [SETQ RANGES (FOR CTAIL C START END ON (FOR CSI IN CSETINFO                                                           COLLECT (CAR CSI)) WHILE CTAIL                         COLLECT (SETQ START (CAR CTAIL))                               (SETQ END START)                               (CONS START (WHILE [AND (CDR CTAIL)                                                           (EQ END (SUB1 (CADR CTAIL]                                              COLLECT (SETQ CTAIL (CDR CTAIL))                                                    (SETQ END (CAR CTAIL]         (* ;; "Split out groups of less than 3.  But if a range exhaustively covers a known subset (like JIS), replace by the name")         [SETQ RANGES (FOR R STR KNOWN LAST IN RANGES                         JOIN (SETQ LAST (CAR (LAST R)))                               (IF (EQ (CAR R)                                           LAST)                                   THEN (CONS (OCTALSTRING (CAR R)))                                 ELSEIF (SETQ KNOWN (SASSOC (SETQ STR (CONCAT (OCTALSTRING                                                                                   (CAR R))                                                                                 "-"                                                                                 (OCTALSTRING LAST)))                                                               XCCS-SET-NAMES))                                   THEN (CONS (CADR KNOWN))                                 ELSEIF (CDDR R)                                   THEN (CONS STR)                                 ELSE (LIST (OCTALSTRING (CAR R))                                                (OCTALSTRING LAST]         (CL:VALUES IMAPPING CSETINFO RANGES])(WRITE-UNICODE-MAPPING-HEADER  [LAMBDA (STREAM CSETINFO RANGES)                      (* ; "Edited  4-Aug-2020 17:38 by rmk:")    (* ;; "Writes the standard per-file header information")    (FOR LINE IN UNICODE-MAPPING-HEADER       DO (PRINTOUT STREAM "#" 2)             (SELECTQ LINE                 (XCCSCHARACTERSETS                       (PRINTOUT STREAM "        XCCS charset")                      (IF (CDR CSETINFO)                          THEN (PRINTOUT STREAM "s:" -4)                                (FOR R IN RANGES DO (PRINTOUT STREAM R " "))                                (TERPRI STREAM)                        ELSE                             (* ; "Singleton")                              (PRINTOUT STREAM ": " -4 (CADAR CSETINFO)                                     " "                                     (CADDAR CSETINFO)))                      (TERPRI STREAM))                 (DATE (PRINTOUT STREAM "        Date:" -13 (DATE (DATEFORMAT NO.TIME                                                                          NO.LEADING.SPACES))                              T))                 (PRINTOUT STREAM LINE T)))    (TERPRI STREAM])(WRITE-UNICODE-MAPPING-FILENAME  [LAMBDA (FILE CSETINFO RANGES)                        (* ; "Edited  4-Aug-2020 19:34 by rmk:")    (PACKFILENAME 'BODY [OR FILE (CONCATLIST                                  (CONS 'XCCS- (IF (CDR CSETINFO)                                                   THEN (FOR RTAIL R ON RANGES                                                               JOIN (SETQ R (CAR RTAIL))                                                                     (SETQ R                                                                      (CL:IF (LISTP R)                                                                          (LIST (CAR R)                                                                                "-"                                                                                (CDR R))                                                                          (CONS R)))                                                                     (CL:IF (CDR RTAIL)                                                                            (NCONC1 R ","))                                                                     R)                                                 ELSE (LIST (CADAR CSETINFO)                                                                "="                                                                (CADDAR CSETINFO]           'DIRECTORY           (CAR UNICODEDIRECTORIES)           'EXTENSION           'TXT]))(RPAQQ XCCS-SET-NAMES       (("0" LATIN)        ("41" SYMBOLS1)        ("42" SYMBOLS2)        ("43" EXTENDED-LATIN)        ("44" HIRAGANA)        ("45" KATAKANA)        ("46" GREEK)        ("47" CYRILLIC)        ("50" FORMS)        ("60-172" JIS)        ("340" ARABIC)        ("341" HEBREW)        ("342" IPA)        ("343" HANGUL)        ("344" GEORGIAN-ARMENIAN)        ("356" SYMBOLS3)        ("357" SYMBOLS4)        ("360" LIGATURES)        ("361" ACCENTED-LATIN)        ("365" MORE-ARABIC)        ("375" GRAPHIC-VARIANTS)))(* ;; "Automate dumping of a documentation prefix")(DECLARE%: EVAL@COMPILE DONTCOPY (DECLARE%: EVAL@COMPILE (RPAQ MISSINGCODE (CL:PARSE-INTEGER "FFFE" :RADIX 16))(RPAQ UNDEFINEDCODE (CL:PARSE-INTEGER "FFFF" :RADIX 16))(CONSTANTS (MISSINGCODE (CL:PARSE-INTEGER "FFFE" :RADIX 16))       (UNDEFINEDCODE (CL:PARSE-INTEGER "FFFF" :RADIX 16)))))(RPAQQ UNICODE-MAPPING-HEADER       ("" "        Name:             XCCS (XC-3-1-1-0) to Unicode" "        Unicode version:  3.0"            XCCSCHARACTERSETS "        Table version:    0.1" "        Table format:     Format A"            DATE "        Author:           Ron Kaplan <Ron.Kaplan@post.harvard.edu>" ""            "This file contains mappings from the Xerox Character Code Standard (version"            "XC1-3-3-0, 1987) into Unicode 3.0. standard codes.  That is the version of"            "XCCS corresponding to the fonts in the Medley system." ""            "The format of this file conforms to the format of the other Unicode-supplied"            "mapping files:" "   Three white-space (tab or spaces) separated columns:"            "     Column 1 is the XCCS code (as hex 0xXXXX)"            "     Column 2 is the corresponding Unicode (as hex 0xXXXX)"            "     Column 3 (after #) is a comment column. For convenience, it contains the"            "        Unicode character itself (since the Unicode character names"            "        are not available)"            "Unicode FFFF is used for undefined XCCS codes (Column 3 = UNDEFINED"            "Unicode FFFE is used for XCCS codes that have not yet been filled in."            "(Column 3 = MISSING)" "" "This file is encoded in UTF8, so that the Unicode characters"            "are properly displayed in Column 3 and can be edited by standard"            "Unicode-enabled editors (e.g. Mac Textedit)." ""            "This file can also be read by the function"            "READ-UNICODE-MAPPING in the UNICODE Medley library package." ""            "The entries are in XCCS order and grouped by character sets.  In front of"            "the mappings, for convenience, there is a line with the octal XCCS"            "character set, after #." ""            "Note that a given XCCS code might map to codes in several different Unicode"            "positions, since there are repetitions in the Unicode standard." ""            "For more details, see the associated README.TXT file." ""            "Any comments or problems, contact <ron.kaplan@post.harvard.edu>"))(RPAQ? UNICODEDIRECTORIES NIL)(PUSHNEW UNICODEDIRECTORIES (PACK* (UNIX-GETENV "MEDLEYDIR")                                       '/lispcore/unicode/xerox/))(* ;; "Set up translation tables for UTF8 and UTFBE external formats")(DEFINEQ(MAKE-UNICODE-TRANSLATION-TABLES  [LAMBDA (MAPPING LTORVAR RTOLVAR EXTERNALEOL)         (* ; "Edited  1-Aug-2020 09:38 by rmk:")    (* ;; "MAPPING is the list of numeric code correspondence pairs constructed by applying READ-UNICODE-MAPPING to a Unicode mapping file.")    (* ;; "This produces two recoding arrays, one maps left-side codes into right-side codes (e.g. XCCS or ISO8859-1 to Unicode), for printing, the other maps right-side (Unicode) codes to corresponding right-side codes (e.g. XCCS).")    (* ;; "")    (* ;; "We assume that the left-to-right mapping into Unicode is functional, so that each left code maps to a unique right (Unicode) code, because Unicode is presumably the most refined coding scheme.  But several Unicode codes may map to the same left code, for logically different codes that happen to have the same glyphs. In that case the heuristic is to map each %"from%" code to the lowest of the possible %"to%" codes. This means that round-trip reading/writing or writing/reading from one or both starting points may not always be lossless.")    (* ;; " ")    (* ;; " Each recoding array has 256 elements, one for each possible high-order byte of a character code.  An array entry is either NIL, a 256-array of codes indexed by low-order bytes, or an alist of (lower-order-bytes . codes).  The latter is used to save space for sparsely populated character sets.")    (* ;; "")    (* ;; "The absence of a recoding (NIL) is treated as an identity.")    (* ;; "")    (* ;; "For the convenience of not having to deal with the multiple values, if LTORVAR or RTOLVAR are given, they are set to the constructed arrays before return.")    (CL:UNLESS EXTERNALEOL                                   (* ; "Unix default")        (SETQ EXTERNALEOL (CHARCODE LF)))    (LET ((LTORARRAY (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))          (RTOLARRAY (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL)))         (* ;; "The left-to-right direction (into Unicode).    We start by distributing the mappings into alists in arrays indexed by the higher-order (charaset set byte).  The second loop converts long alists into arrays.")         [FOR PAIR LEFTC RIGHTC IN MAPPING UNLESS (OR (EQ (SETQ LEFTC (CAR PAIR))                                                                      (SETQ RIGHTC (CADR PAIR)))                                                                  (IGEQ RIGHTC MISSINGCODE))            DO (CL:WHEN (EQ LEFTC (CHARCODE EOL))                          (SETQ LEFTC EXTERNALEOL))                  (CL:PUSH (CONS (LOGAND LEFTC 255)                                 RIGHTC)                         (CL:SVREF LTORARRAY (LRSH LEFTC 8]         (FOR I CSA FROM 0 TO 255 WHEN (IGREATERP (LENGTH (CL:SVREF LTORARRAY I))                                                              20)            DO                   (* ;; "Leave it alone if the alist is short")                  (SETQ CSA (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))                  (FOR P IN (CL:SVREF LTORARRAY I)                     DO (CL:SETF (CL:SVREF CSA (LOGAND (CAR P)                                                          255))                                   (CDR P)))                   (* ;; "Fill in the identities in the array case--avoid an extra NIL test in translating, and allows for identity testing below")                  (FOR J FROM 0 TO 255 UNLESS (CL:SVREF CSA J)                     DO (CL:SETF (CL:SVREF CSA J)                                   (LOGOR (LLSH I 8)                                          J)))                  (CL:SETF (CL:SVREF LTORARRAY I)                         CSA))         (* ;; "")         (* ;; "Now the right-to-left direction (from Unicode). Here we have to detect and compensate for ambiguity.")         (* ;;  "Thus, we don't suppress identities in the alist, so that the PREV test below is always complete.")         (FOR PAIR LEFTC RIGHTC PREV IN MAPPING UNLESS (IGEQ (SETQ RIGHTC (CADR PAIR))                                                                         MISSINGCODE)            DO (SETQ LEFTC (CAR PAIR))                  (CL:WHEN (EQ RIGHTC EXTERNALEOL)                      (SETQ RIGHTC (CHARCODE EOL)))                   (* ;; "Have we already seen an explicit mapping from right to left?")                  [SETQ PREV (ASSOC (LOGAND RIGHTC 255)                                    (CL:SVREF RTOLARRAY (LRSH RIGHTC 8]                  (IF (NULL PREV)                      THEN (CL:PUSH (CONS (LOGAND RIGHTC 255)                                              LEFTC)                                      (CL:SVREF RTOLARRAY (LRSH RIGHTC 8)))                    ELSEIF (IGREATERP (CDR PREV)                                      LEFTC)                      THEN (RPLACD PREV LEFTC)))         (* ;; "Since we didn't suppress identities before, and we still want to conserve a little storage, we have to count the number of non-identities here")         [FOR I CSA FROM 0 TO 255            DO (IF (FOR P (CNT _ 1) IN (CL:SVREF RTOLARRAY I)                              UNLESS (EQ (CAR P)                                             (CDR P)) DO (ADD CNT 1)                                                            (CL:WHEN (EQ CNT 20)                                                                   (RETURN T)))                       THEN (SETQ CSA (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT NIL))                             (FOR P IN (CL:SVREF RTOLARRAY I)                                DO (CL:SETF (CL:SVREF CSA (LOGAND (CAR P)                                                                     255))                                              (CDR P)))                             (FOR J FROM 0 TO 255 UNLESS (CL:SVREF CSA J)                                DO (CL:SETF (CL:SVREF CSA J)                                              (LOGOR (LLSH I 8)                                                     J)))                             (CL:SETF (CL:SVREF RTOLARRAY I)                                    CSA)                     ELSE                            (* ;; "Shrink the alist to nonidentities")                           (CL:SETF (CL:SVREF RTOLARRAY I)                                  (FOR P IN (CL:SVREF RTOLARRAY I)                                     UNLESS (EQ (CAR P)                                                    (CDR P)) COLLECT P]         (CL:WHEN LTORVAR (SETATOMVAL LTORVAR LTORARRAY))         (CL:WHEN RTOLVAR (SETATOMVAL RTOLVAR RTOLARRAY))         (CL:VALUES LTORARRAY RTOLARRAY]))(RPAQ? DEFAULT-XCCS-CHARSETS '(LATIN SYMBOLS1 SYMBOLS2 EXTENDED-LATIN FORMS SYMBOLS3 SYMBOLS4                                          ACCENTED-LATIN))(DECLARE%: EVAL@COMPILE DONTCOPY (DECLARE%: EVAL@COMPILE (PUTPROPS UNICODE.TRANSLATE MACRO [OPENLAMBDA (CODE TRANSLATION-TABLE)                                            (LET [(X (CL:SVREF TRANSLATION-TABLE (LRSH CODE 8]                                                 (COND                                                    ((LISTP X)                                                     (OR (CDR (FASSOC (LOGAND CODE 255)                                                                     X))                                                         CODE))                                                    (T (CL:SVREF X (LOGAND CODE 255])))(DECLARE%: DONTEVAL@LOAD DOCOPY (MAKE-UNICODE-TRANSLATION-TABLES (READ-UNICODE-MAPPING DEFAULT-XCCS-CHARSETS T)       '*XCCSTOUNICODE*       '*UNICODETOXCCS*))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS *XCCSTOUNICODE* *UNICODETOXCCS*))(DEFINEQ(HEXSTRING  [LAMBDA (N WIDTH)                                     (* ; "Edited 23-Jul-2020 08:28 by rmk:")                                                             (* ; "Edited 20-Dec-93 17:51 by rmk:")    (* ;;   "Converts positive numbers to Hex strings, padding on the right with 0 up to WIDTH if given.")    (CL:UNLESS (FIXP N)        (SETQ N (CHARCODE.DECODE N)))    (LET [CHAR (STR (ALLOCSTRING [IMAX (OR WIDTH 0)                                       (FOR I (LEFT _ N) FROM 0 UNTIL (EQ LEFT 0)                                          DO (SETQ LEFT (LRSH LEFT 4))                                          FINALLY (RETURN (MAX I 1]                           (CHARCODE 0]         (FOR I FROM -1 BY -1 UNTIL (EQ N 0)            DO (SETQ CHAR (LOGAND N 15))                  [RPLCHARCODE STR I (IF (ILESSP CHAR 10)                                         THEN (+ CHAR (CHARCODE 0))                                       ELSE (+ (- CHAR 10)                                                   (CHARCODE A]                  (SETQ N (LRSH N 4)))         STR])(UTF8STRING  [LAMBDA (CHARCODE)                                    (* ; "Edited  6-Aug-2020 07:47 by rmk:")                                                            (* ; "Edited 30-Jan-2020 23:08 by rmk:")    (* ;; "Utility to produces the UTF8 hexstring representing CODE")    (HEXSTRING (IF (ILESSP CHARCODE 128)                       THEN CHARCODE                     ELSEIF (ILESSP CHARCODE 2048)                       THEN                              (* ; "x800")                             (LOGOR (LLSH (LOGOR (LLSH 3 6)                                                 (LRSH CHARCODE 6))                                          8)                                    (LOGOR (LLSH 2 6)                                           (LOADBYTE CHARCODE 0 6)))                     ELSEIF (ILESSP CHARCODE 65536)                       THEN                              (* ; "x10000")                             (LOGOR (LLSH (LOGOR (LLSH 7 5)                                                 (LRSH CHARCODE 12))                                          16)                                    (LLSH (LOGOR (LLSH 2 6)                                                 (LOADBYTE CHARCODE 6 6))                                          8)                                    (LOGOR (LLSH 2 6)                                           (LOADBYTE CHARCODE 0 6)))                     ELSEIF (ILESSP CHARCODE 2097152)                       THEN                              (* ; "x200000")                             (LOGOR (LLSH (LOGOR (LLSH 15 4)                                                 (LRSH CHARCODE 18))                                          24)                                    (LLSH (LOGOR (LLSH 2 6)                                                 (LOADBYTE CHARCODE 12 6))                                          16)                                    (LLSH (LOGOR (LLSH 2 6)                                                 (LOADBYTE CHARCODE 6 6))                                          8)                                    (LOGOR (LLSH 2 6)                                           (LOADBYTE CHARCODE 0 6)))                     ELSE (ERROR "CHARCODE too big for UTF8" CHARCODE]))(DEFINEQ(SHOWCHARS  [LAMBDA (FROMCHAR TOCHAR FONT)                        (* ; "Edited  1-Aug-2020 09:27 by rmk:")    (RESETFORM (DSPFONT (OR FONT '(CLASSIC 12))                      T)           (CL:WHEN (AND (SMALLP FROMCHAR)                         (NOT TOCHAR))               (* ;;     "If a small number, assume it's an octal (in decimal) character set, no need for string quotes")               (SETQ TOCHAR (CONCAT FROMCHAR "," 376))               (SETQ FROMCHAR (CONCAT FROMCHAR "," 41)))           (CL:UNLESS (SMALLP FROMCHAR)               (SETQ FROMCHAR (CHARCODE.DECODE FROMCHAR)))           (CL:UNLESS (SMALLP TOCHAR)               (SETQ TOCHAR (CL:IF TOCHAR                                (CHARCODE.DECODE TOCHAR)                                FROMCHAR)))           (FOR C FROM FROMCHAR TO TOCHAR UNLESS (AND (IGEQ (LOGAND C 255)                                                                            127)                                                                      (ILEQ (LOGAND C 255)                                                                            (PLUS 128 33)))              DO (PRINTOUT T .P2 (CONCAT (OCTALSTRING (LRSH CODE 8))                                            ","                                            (OCTALSTRING (LOGAND CODE 255)))                            10                            (CHARACTER C)                            T]))(DECLARE%: EVAL@COMPILE DONTCOPY (DECLARE%: EVAL@COMPILE (RPAQQ LF.EOLC 1)(CONSTANTS (LF.EOLC 1)))(EVAL (SYSRECLOOK1 'EXTERNALFORMAT)))(DECLARE%: DONTCOPY  (FILEMAP (NIL (3316 15086 (UTF8.OUTCHARFN 3326 . 5196) (UTF8.INCCODEFN 5198 . 9297) (UTF8.PEEKCCODEFN 9299 . 14577) (\UTF8.BACKCHARFN 14579 . 15084)) (15087 18196 (UTF16BE.OUTCHARFN 15097 . 15617) (UTF16BE.INCCODEFN 15619 . 16496) (UTF16BE.PEEKCCODEFN 16498 . 17753) (\UTF16.BACKCHARFN 17755 . 18194)) (18197 21871 (MAKE-UNICODE-FORMATS 18207 . 21869)) (21995 37526 (READ-UNICODE-MAPPING-FILENAMES 22005 . 23167) (READ-UNICODE-MAPPING 23169 . 26060) (WRITE-UNICODE-MAPPING 26062 . 30034) (WRITE-UNICODE-INCLUDED 30036 . 34758) (WRITE-UNICODE-MAPPING-HEADER 34760 . 35992) (WRITE-UNICODE-MAPPING-FILENAME 35994 . 37524)) (40872 47740 (MAKE-UNICODE-TRANSLATION-TABLES 40882 . 47738)) (48822 52308 (HEXSTRING 48832 . 49993) (UTF8STRING 49995 . 52306)) (52309 53778 (SHOWCHARS 52319 . 53776)))))STOP